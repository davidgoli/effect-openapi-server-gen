/**
 * Generated by @effect/openapi-server-gen
 *
 * DO NOT EDIT THIS FILE MANUALLY
 *
 * This file was automatically generated from an OpenAPI specification.
 * To regenerate, run the generator again with your OpenAPI spec.
 */

import * as HttpApi from "@effect/platform/HttpApi"
import * as HttpApiEndpoint from "@effect/platform/HttpApiEndpoint"
import * as HttpApiGroup from "@effect/platform/HttpApiGroup"
import * as HttpApiSchema from "@effect/platform/HttpApiSchema"
import * as Schema from "effect/Schema"

// Schema definitions from components/schemas
const PersonaRowTypeSchema = Schema.Union(Schema.Literal("contacts"), Schema.Literal("text"), Schema.Literal("ama_topic"), Schema.Literal("instructor_list"), Schema.Literal("additional_content"), Schema.Literal("pill"), Schema.Literal("text_column"))
const InstructorAvailabilityStatusSchema = Schema.Union(Schema.Literal("available"), Schema.Literal("upcoming"))
const PlanGBFeatureSchema = Schema.Struct({
  bucketName: Schema.optional(Schema.String.annotations({ description: "If the feature is related to an experiment, this is the name of the bucket associated with the variant." })),
  plans: Schema.optional(Schema.Array(Schema.Struct({
  display_name: Schema.String,
  stripe: Schema.optional(PlanGBFeatureCommerceGatewayProductSchema),
  apple: Schema.optional(PlanGBFeatureCommerceGatewayProductSchema)
})))
})
const PlanGBFeatureCommerceGatewayProductSchema = Schema.Struct({
  product_id: Schema.String.annotations({ description: "The identifier of the product resource found in the gateway. Maps to the resource_identifier in the PlanCommerceGatewayProduct.
" })
})
const CalendarAuthStatusSchema = Schema.Union(Schema.Literal("authorized"), Schema.Literal("unauthorized"), Schema.Literal("notAsked"))
const SilentCoachFeedbackRatingSchema = Schema.Union(Schema.Literal("needs_improvement"), Schema.Literal("average"), Schema.Literal("good"))
const ProductSchema = Schema.Struct({
  uuid: Schema.String.annotations({ description: "The UUID of the product" })
})
const UserAnalyticsSchema = Schema.Struct({
  user_id: Schema.String.annotations({ description: "The id of the user for which the analytics are being fetched. Note that we typically use the core product's user id,
and not the UUID found in the User object.
" }),
  persona_user_id: Schema.optional(Schema.String.annotations({ description: "The persona id of the user for which the analytics are being fetched.
" })),
  anonymous_id: Schema.optional(Schema.String.annotations({ description: "The anonymous id of the user for which the analytics are being fetched.
" })),
  user_plan_status: Schema.optional(Schema.String.annotations({ description: "The status of the user's plan. This can be one of the following values: \"active\", \"trialing\", \"past_due\", \"canceled\", \"unpaid\", \"incomplete\".
" })),
  properties: Schema.optional(Schema.Struct({}).annotations({ description: "A dictionary of properties for the user.
" }))
}).annotations({ description: "Analytics for a user. This data should not be used for application logic, but only for analytics purposes.
" })
const UserSchema = Schema.Struct({
  uuid: Schema.String.annotations({ description: "The UUID of the user" }),
  accessible_products: Schema.optional(Schema.Array(ProductSchema).annotations({ description: "A list of accessible products for the user.
In all existing cases, a user has access to at most one product.
" })),
  purchase_eligibility: Schema.optional(Schema.Struct({
  eligible: Schema.optional(Schema.Boolean.annotations({ description: "Whether the user is eligible to purchase a product. False if the user already has an accessible product.
" })),
  trial_period_in_days: Schema.optional(Schema.Number.annotations({ description: "The number of days the user is eligible for a trial period.
If the user is not eligible for a trial period, this value is not provided.
" }))
}).annotations({ description: "A user's eligibility to purchase a product.
" })),
  should_show_roleplay_onboarding: Schema.optional(Schema.Boolean.annotations({ description: "Whether the user should see the roleplay onboarding.
This is true if the user has not completed the onboarding and has not been shown it before.
" })),
  onboarding_type: Schema.optional(Schema.String.annotations({ description: "The type of onboarding the user has completed.
See `OnboardingTypeValue` for available values.
" })),
  name: Schema.optional(Schema.String.annotations({ description: "The name of the user" })),
  email: Schema.optional(Schema.String.annotations({ description: "The email address of the user" })),
  coach_consent: Schema.optional(Schema.Union(Schema.Boolean.annotations({ description: "Whether the user has consented to use the coach product" }), Schema.Null)),
  career_info: Schema.optional(Schema.Struct({
  slug: Schema.optional(Schema.String.annotations({ description: "The slug of the career" })),
  title: Schema.optional(Schema.String.annotations({ description: "The title of the career" }))
})),
  analytics: UserAnalyticsSchema
})
const ErrorSchema = Schema.Struct({
  message: Schema.optional(Schema.String.annotations({ description: "A human-readable error message" }))
})
const UpdateUserRequestSchema = Schema.Struct({
  email_opt_out: Schema.optional(Schema.Boolean.annotations({ description: "true if user does not want to recieve marketing emails." })),
  name: Schema.optional(Schema.String.annotations({ description: "The name of the user" })),
  coach_consented: Schema.optional(Schema.Boolean.annotations({ description: "Whether the user has consented to use the coach product" })),
  career_info: Schema.optional(Schema.Struct({
  slug: Schema.optional(Schema.String.annotations({ description: "The slug of the career" })),
  title: Schema.optional(Schema.String.annotations({ description: "The title of the career" }))
}))
})
const PersonaOnboardingNameInfoSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title for the name section" })),
  subtitle: Schema.optional(Schema.String.annotations({ description: "Subtitle for the name section" }))
}))
})
const PersonaOnboardingJobTitleInfoSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title for the job title section" })),
  subtitle: Schema.optional(Schema.String.annotations({ description: "Subtitle for the job title section" }))
}))
})
const ImageResourceSchema = Schema.Struct({
  url: Schema.String.annotations({ description: "Image URL" }),
  width: Schema.optional(Schema.Number.annotations({ description: "Image width" })),
  height: Schema.optional(Schema.Number.annotations({ description: "Image height" })),
  alt_text: Schema.String.annotations({ description: "Image alt text" })
})
const PersonaOnboardingInstructorSchema = Schema.Struct({
  images: Schema.optional(Schema.Struct({
  instructor_image_2x3: Schema.optional(ImageResourceSchema)
})),
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Instructor name" })),
  areas_of_expertise: Schema.optional(Schema.Array(Schema.String).annotations({ description: "Array of descriptive captions for the instructor" }))
})),
  require_skills: Schema.optional(Schema.Boolean.annotations({ description: "Indicates if skills selection is required for this instructor" })),
  instructor_slug: Schema.optional(Schema.String.annotations({ description: "Unique identifier for the instructor to be sent to the server upon selection" })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the instructor" }))
})
const PersonaOnboardingInstructorsInfoSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title for the instructors section" })),
  subtitle: Schema.optional(Schema.String.annotations({ description: "Subtitle for the instructors section" }))
})),
  instructors: Schema.optional(Schema.Array(PersonaOnboardingInstructorSchema))
})
const PersonaOnboardingSkillSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  label: Schema.optional(Schema.String.annotations({ description: "Title for the skill" }))
})),
  skill_slug: Schema.optional(Schema.String.annotations({ description: "Unique identifier for the skill to be sent to the server upon selection" })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the skill" }))
})
const PersonaOnboardingSkillsInfoSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title for the skills section" })),
  subtitle: Schema.optional(Schema.String.annotations({ description: "Subtitle for the skills section" }))
})),
  skills: Schema.optional(Schema.Array(PersonaOnboardingSkillSchema))
})
const PersonaOnboardingCareerSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  label: Schema.optional(Schema.String.annotations({ description: "Human-readable name for the career" }))
})),
  slug: Schema.optional(Schema.String.annotations({ description: "Unique identifier for the career to be sent to the server upon selection" })),
  require_job_title: Schema.optional(Schema.Boolean.annotations({ description: "Indicates if job title is required for this career selection" })),
  require_skills: Schema.optional(Schema.Boolean.annotations({ description: "Indicates if skills selection is required for this instructor" })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the career" }))
})
const PersonaOnboardingCareersInfoSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title for the careers section" })),
  subtitle: Schema.optional(Schema.String.annotations({ description: "Subtitle for the careers section" }))
})),
  careers: Schema.optional(Schema.Array(PersonaOnboardingCareerSchema))
})
const PersonaOnboardingResponseSchema = Schema.Struct({
  name_info: Schema.optional(PersonaOnboardingNameInfoSchema),
  job_title_info: Schema.optional(PersonaOnboardingJobTitleInfoSchema),
  instructors_info: Schema.optional(PersonaOnboardingInstructorsInfoSchema),
  skills_info: Schema.optional(PersonaOnboardingSkillsInfoSchema),
  careers_info: Schema.optional(PersonaOnboardingCareersInfoSchema)
})
const OnboardingRequestSchema = Schema.Struct({
  instructor_slugs: Schema.optional(Schema.Array(Schema.String)),
  skill_slugs: Schema.optional(Schema.Array(Schema.String)),
  career_info: Schema.optional(Schema.Struct({
  slug: Schema.optional(Schema.String.annotations({ description: "The slug of the career" })),
  title: Schema.optional(Schema.String.annotations({ description: "The title of the career" }))
}))
})
const CommerceGatewaySubscriptionSchema = Schema.Struct({
  product_display_name: Schema.optional(Schema.String),
  is_free_trial: Schema.Boolean,
  renews_at: Schema.optional(Schema.String),
  renews_at_timestamp: Schema.optional(Schema.String),
  expires_at: Schema.optional(Schema.String),
  expires_at_timestamp: Schema.optional(Schema.String),
  trial_ends_at: Schema.optional(Schema.String),
  trial_ends_at_timestamp: Schema.optional(Schema.String),
  gateway: Schema.optional(Schema.String.annotations({ description: "See `GatewayType` for a list of values." })),
  renewal_canceled: Schema.Boolean.annotations({ description: "Indicates if the subscriptions has renewal canceled" }),
  resource_identifier: Schema.optional(Schema.String),
  product_resource_identifier: Schema.optional(Schema.String)
})
const schemas-ErrorSchema = Schema.Struct({
  message: Schema.optional(Schema.String)
})
const StripeSubscriptionCreateRequestSchema = Schema.Struct({
  price_id: Schema.String.annotations({ description: "The ID of the Stripe price to subscribe to." }),
  payment_method_id: Schema.String.annotations({ description: "The ID of the Stripe payment method to use for the subscription." }),
  currency: Schema.String.pipe(Schema.minLength(3), Schema.maxLength(3)).annotations({ description: "The currency of the subscription. Must be specified as a 3-letter ISO code." }),
  country: Schema.optional(Schema.String.pipe(Schema.minLength(2), Schema.maxLength(2)).annotations({ description: "The country of the subscriber. Must be specified as a 2-letter ISO code.
If not provided, the country will be inferred from the payment method.
" })),
  state: Schema.optional(Schema.String.pipe(Schema.minLength(2), Schema.maxLength(2)).annotations({ description: "The state of the subscriber. Must be specified as a 2-letter ISO code.
If the country is provided, the state must also be provided when the country is US.
" })),
  postal_code: Schema.optional(Schema.String.annotations({ description: "The postal code of the subscriber.
If the country is provided, the postal code must also be provided when the country is CA, IN, or AE.
" })),
  email: Schema.optional(Schema.String.annotations({ description: "The email address of the subscriber.
This field is only required if the user is not authenticated and is subscribing as a guest.
Otherwise, the email address will be taken from the authenticated user's profile, and this field will be ignored.
" })),
  coupon_code: Schema.optional(Schema.String.annotations({ description: "The coupon code to apply to the subscription.
This field is optional and will apply a discount to the subscription if the coupon is valid.
" })),
  analytics: Schema.optional(Schema.Struct({
  anonymous_id: Schema.optional(Schema.String.annotations({ description: "The anonymous ID of the subscriber.
This field is only required if the user is not authenticated and is subscribing as a guest.
Otherwise, the user is identified through their profile, and this field will be ignored.
" }))
}).annotations({ description: "The analytics data of the subscriber.
" }))
})
const StripeSubscriptionResponseSchema = Schema.Struct({
  subscription_id: Schema.String.annotations({ description: "The ID of the Stripe subscription that was continued.
" }),
  renews_at: Schema.optional(Schema.String.annotations({ description: "The date and time when the subscription will renew.
This is the end of the current billing period. After this date, the subscription will renew,
and the user's entitlement to the product will continue. This field will be null if the subscription is
set to expire at the end of the billing period. See expires_at for more information.
" })),
  expires_at: Schema.optional(Schema.String.annotations({ description: "The date and time when the subscription will expire.
This is the end of the current billing period. After this date, the subscription will not renew,
and the user's entitlement to the product will be revoked. This field will be null if the subscription is
set to renew.
" })),
  trial_ends_at: Schema.optional(Schema.String.annotations({ description: "The date and time when the trial period will end.
This field will be null if the subscription is not in a trial period.
" })),
  registration_token: Schema.optional(Schema.String.annotations({ description: "The registration token for the subscription. It is used for the user to complete the registration flow
" })),
  anonymous_id: Schema.optional(Schema.String.annotations({ description: "The anonymous ID for the subscription owner
" })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data" }))
})
const CommerceGatewayProductSchema = Schema.Struct({
  resource_identifier: Schema.optional(Schema.String.annotations({ description: "Resource identifier of the product in a certain provider (like Apple or Stripe)
" })),
  product_id: Schema.optional(Schema.Number.annotations({ description: "Unique identifier of the product in the system
" }))
})
const ProductsResponseSchema = Schema.Struct({
  products: Schema.optional(Schema.Array(CommerceGatewayProductSchema))
})
const PlanCommerceGatewayPriceSchema = Schema.Struct({
  resource_identifier: Schema.String.annotations({ description: "The identifier of the price in the gateway. Clients should use this identifier to purchase the product.
" }),
  currency: Schema.String.annotations({ description: "The currency of the price. 3-letter ISO code.
" }),
  price: Schema.Number.annotations({ description: "The price of the product in the specified currency.  Note this is in the lowest denomination (i.e. - cents)
" }),
  usd_price: Schema.Number.annotations({ description: "The price of the product in usd.
" }),
  analytics: Schema.Struct({})
}).annotations({ description: "The pricing details for the given plan, currency, and country.
" })
const CouponSchema = Schema.Struct({
  category: Schema.String.annotations({ description: "The category of the coupon
" }),
  code: Schema.String.annotations({ description: "The coupon code
" }),
  discount_type: Schema.String.annotations({ description: "The type of discount applied: amount_off or percentage_off
" }),
  percentage: Schema.optional(Schema.Number.annotations({ description: "The percentage discount (0-100)
" })),
  currency: Schema.optional(Schema.String.annotations({ description: "The currency for the coupon
" })),
  price: Schema.optional(Schema.Number.annotations({ description: "The price discount amount in centss
" }))
}).annotations({ description: "Coupon information for a plan
" })
const PlanCommerceGatewayProductSchema = Schema.Struct({
  resource_identifier: Schema.String.annotations({ description: "The identifier of the product resource found in the gateway. Clients should use this identifier to purchase the product.
" }),
  trial_days: Schema.Number.annotations({ description: "The number of trial days for the product. If the product does not have a trial, this will be 0.
" }),
  analytics: Schema.Struct({}),
  price: Schema.optional(PlanCommerceGatewayPriceSchema),
  coupons: Schema.optional(Schema.Array(CouponSchema).annotations({ description: "Available coupons for this gateway product
" }))
}).annotations({ description: "The product resource found in the gateway. This is the product that is purchased by the client.
" })
const PlanSchema = Schema.Struct({
  display_name: Schema.String,
  gateway_products: Schema.Struct({
  stripe: Schema.optional(PlanCommerceGatewayProductSchema),
  apple: Schema.optional(PlanCommerceGatewayProductSchema)
})
}).annotations({ description: "A plan that can be purchased by a client. A plan has commerce gateway products that can be purchased by the client.
" })
const CreateCallRequestSchema = Schema.Struct({
  topic_uuid: Schema.optional(Schema.String.annotations({ description: "Topic UUID" })),
  instructor_slug: Schema.optional(Schema.String.annotations({ description: "Instructor slug" })),
  cpt: Schema.optional(Schema.Boolean.annotations({ description: "feature flip for CPT model" })),
  kind: Schema.Union(Schema.Literal("text"), Schema.Literal("voice"), Schema.Literal("roleplay"), Schema.Literal("debrief_voice")),
  roleplay_scenario: Schema.optional(Schema.Struct({
  user_role_play_uuid: Schema.optional(Schema.String.annotations({ description: "user_role_play_scenario_uuid" }))
}))
})
const CallErrorResponseSchema = Schema.Struct({
  error_code: Schema.optional(Schema.String.annotations({ description: "This error code would be of type `CallErrorCode`" })),
  error_message: Schema.optional(Schema.String.annotations({ description: "Error message" }))
})
const CallResponseSchema = Schema.Struct({
  call_details: Schema.optional(Schema.Struct({
  uuid: Schema.optional(Schema.String.annotations({ description: "Call UUID" })),
  bot_id: Schema.optional(Schema.String.annotations({ description: "Bot ID" })),
  voice_token: Schema.optional(Schema.String.annotations({ description: "JWT with cortex information" })),
  idle_timeout: Schema.optional(Schema.Number.annotations({ description: "Idle time out for the bot in seconds" })),
  images: Schema.optional(Schema.Struct({
  instructor_1x1: ImageResourceSchema
}).annotations({ description: "Image to displayed during the call" })),
  text: Schema.optional(Schema.Struct({
  instructor_name: Schema.optional(Schema.String.annotations({ description: "Instructor name" })),
  utterance_text: Schema.optional(Schema.String.annotations({ description: "Initial text that is spoken by the bot" })),
  cta: Schema.optional(Schema.String.annotations({ description: "Display text for the topic" }))
}).annotations({ description: "Text to be displayed during the call" })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the call" }))
}).annotations({ description: "Contains all the details to place the call." })),
  text_details: Schema.optional(Schema.Struct({
  dialog_uuid: Schema.optional(Schema.String.annotations({ description: "Dialog UUID" })),
  conversation_uuid: Schema.optional(Schema.String.annotations({ description: "Conversation UUID" })),
  images: Schema.optional(Schema.Struct({
  instructor_1x1: ImageResourceSchema
}).annotations({ description: "Image to displayed for text chat" })),
  text: Schema.optional(Schema.Struct({
  instructor_name: Schema.optional(Schema.String.annotations({ description: "Instructor name" })),
  cta: Schema.optional(Schema.String.annotations({ description: "Display text for the topic" }))
}).annotations({ description: "Text to be displayed for text chat" })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the call" }))
}).annotations({ description: "Contains all the details for text chat." })),
  text_enabled: Schema.optional(Schema.Boolean.annotations({ description: "Whether text is enabled for the instructor" })),
  additional_content_details: Schema.optional(Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title of the footer" })),
  subtitle_collapsed: Schema.optional(Schema.String.annotations({ description: "Subtitle of the footer when the footer view is collapsed" })),
  subtitle_expanded: Schema.optional(Schema.String.annotations({ description: "Subtitle of the footer when the footer view is expanded" }))
})),
  redirect_urls: Schema.optional(Schema.Struct({
  cta: Schema.optional(Schema.String.annotations({ description: "URL to redirect when the footer view is clicked" })),
  detail_ui: Schema.optional(Schema.String.annotations({ description: "URL to show the detail ui of the content once the call has initiated" }))
}).annotations({ description: "URLs to redirect to" })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the call" }))
}).annotations({ description: "Contains details that are to be displayed on the call UI" })),
  roleplay_session_details: Schema.optional(Schema.Struct({
  roleplay_session_token: Schema.optional(Schema.String.annotations({ description: "JWT for the roleplay session" })),
  conversation_uuid: Schema.optional(Schema.String.annotations({ description: "Unique identifier for the roleplay session" })),
  idle_timeout: Schema.optional(Schema.Number.annotations({ description: "Idle time out for the bot" })),
  text: Schema.optional(Schema.Struct({
  ai_name: Schema.optional(Schema.String.annotations({ description: "Name of the AI participant" })),
  title: Schema.optional(Schema.String),
  tips: Schema.optional(Schema.Array(Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String)
}))
})).annotations({ description: "Guidance information for the scenario" }))
}).annotations({ description: "Text elements for the roleplay scenario" })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the call" }))
}).annotations({ description: "Contains specific details about the roleplay session" })),
  error: Schema.optional(CallErrorResponseSchema)
})
const UpdateCallRequestSchema = Schema.Struct({
  provider_call_id: Schema.String.annotations({ description: "Call ID of the AI SDK provider to track the conversation (for mapping the call with the bot used on the provider)" }),
  call_state: Schema.String.annotations({ description: "See `CallState` for available call states." })
})
const BannerSchema = Schema.Struct({
  images: Schema.optional(Schema.Struct({
  instructor_1x1: Schema.optional(ImageResourceSchema),
  instructor: Schema.optional(ImageResourceSchema),
  instructor_16x9: Schema.optional(ImageResourceSchema)
}).annotations({ description: "Images to displayed on the banner" })),
  videos: Schema.optional(Schema.Struct({
  trailer_video_uuid: Schema.optional(Schema.String.annotations({ description: "UUID of the video that is autoplayed or played when the user hovers over the banner" }))
}).annotations({ description: "List of videos to be displayed on the banner" })),
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title of the banner" })),
  description: Schema.optional(Schema.String.annotations({ description: "Description of the banner" })),
  tags: Schema.optional(Schema.Array(Schema.String).annotations({ description: "Tags to be displayed on the banner" }))
}).annotations({ description: "Text to be displayed on the banner" })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the banner" }))
}).annotations({ description: "Instructor information to be displayed on the banner" })
const PersonaRowHeaderCtaSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title of the CTA" }))
}).annotations({ description: "Text to be displayed on the CTA" })),
  redirect_url: Schema.optional(Schema.String.annotations({ description: "URL to redirect to" })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the CTA" }))
}).annotations({ description: "CTA for the persona row header" })
const PersonaRowHeaderSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title of the header" }))
}).annotations({ description: "Text to be displayed on the header" })),
  ctas: Schema.optional(Schema.Struct({
  see_all: Schema.optional(PersonaRowHeaderCtaSchema)
}).annotations({ description: "CTAs for the persona row header" }))
}).annotations({ description: "Header for the persona row" })
const TextRowItemSchema = Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title of the text row" })),
  subtitle: Schema.optional(Schema.String.annotations({ description: "Subtitle of the text row" })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the text row" }))
}).annotations({ description: "This row only contains the title and subtitle" })
const TextColumnRowItemSchema = Schema.Struct({
  text: Schema.optional(Schema.String.annotations({ description: "Text to be displayed on the column" })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the text column row" }))
}).annotations({ description: "This row contains text to be displayed in a column" })
const ContactRowItemSchema = Schema.Struct({
  images: Schema.optional(Schema.Struct({
  instructor_1x1: Schema.optional(ImageResourceSchema),
  instructor_2x3: Schema.optional(ImageResourceSchema)
}).annotations({ description: "Image to displayed on the contact card" })),
  videos: Schema.optional(Schema.Struct({
  cover_video_uuid: Schema.optional(Schema.String.annotations({ description: "UUID of the video that is autoplayed or played when the user hovers over the card" }))
}).annotations({ description: "List of videos to be displayed on the card" })),
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Name of the contact (bot)" })),
  subtitle: Schema.optional(Schema.String.annotations({ description: "Subtitle of the contact card" })),
  badge: Schema.optional(Schema.String.annotations({ description: "Badge displayed on the card" })),
  cta: Schema.optional(Schema.String.annotations({ description: "Text to be displayed on the CTA button" }))
}).annotations({ description: "Text to be displayed on the contact card" })),
  redirect_urls: Schema.optional(Schema.Struct({
  card: Schema.optional(Schema.String.annotations({ description: "URL to redirect to when the card is clicked" })),
  cta: Schema.optional(Schema.String.annotations({ description: "URL to redirect to when the CTA button is clicked" })),
  chat_cta: Schema.optional(Schema.String.annotations({ description: "URL to redirect to when the CTA chat button is clicked" }))
}).annotations({ description: "URLs to redirect to" })),
  status: Schema.optional(Schema.String.annotations({ description: "Availability status of the bot. See `InstructorAvailabilityStatus` for available statuses." })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the contact row" }))
}).annotations({ description: "This row contains the contact details of the bot" })
const TopicRowItemSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  display_text: Schema.optional(Schema.String.annotations({ description: "Primary text displayed on top of the card" })),
  utterance_text: Schema.optional(Schema.String.annotations({ description: "Initial text that is spoken by the bot" })),
  caption: Schema.optional(Schema.String.annotations({ description: "Caption displayed on the card" }))
}).annotations({ description: "Text to be displayed on the topic card" })),
  images: Schema.optional(Schema.Struct({
  instructor_1x1: Schema.optional(ImageResourceSchema)
}).annotations({ description: "Image to displayed on the topic card" })),
  redirect_url: Schema.optional(Schema.String.annotations({ description: "URL to redirect to" })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the topic row item" }))
}).annotations({ description: "This row contains the topics to initiate a call" })
const PillRowItemSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title displayed on the pill" })),
  subtitle: Schema.optional(Schema.String.annotations({ description: "Subtitle displayed on the pill" }))
}).annotations({ description: "Text to be displayed on the pill" })),
  images: Schema.optional(Schema.Struct({
  leading_image_1x1: Schema.optional(ImageResourceSchema),
  trailing_image_1x1: Schema.optional(ImageResourceSchema)
}).annotations({ description: "Image to displayed on the pill" })),
  redirect_url: Schema.optional(Schema.String.annotations({ description: "URL to redirect to" })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the pill row item" }))
}).annotations({ description: "This row contains the pill details" })
const PersonaBadgeSchema = Schema.Struct({
  background_color: Schema.optional(Schema.String.annotations({ description: "Color of the badge" })),
  images: Schema.optional(Schema.Struct({
  icon_trailing: Schema.optional(ImageResourceSchema)
}).annotations({ description: "Images to displayed on the badge" })),
  text: Schema.optional(Schema.Struct({
  primary: Schema.optional(Schema.String.annotations({ description: "Primary text displayed on the badge" }))
}).annotations({ description: "Text to be displayed on the badge" }))
}).annotations({ description: "Details about a badge" })
const InstructorCardRowItemSchema = Schema.Struct({
  images: Schema.optional(Schema.Struct({
  instructor_1x1: Schema.optional(ImageResourceSchema),
  instructor_2x3: Schema.optional(ImageResourceSchema),
  instructor_16x9: Schema.optional(ImageResourceSchema)
}).annotations({ description: "Image to displayed on the card" })),
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title of the card" })),
  subtitle: Schema.optional(Schema.String.annotations({ description: "Subtitle of the card" })),
  tags: Schema.optional(Schema.Array(Schema.String).annotations({ description: "Prompt text to be displayed" })),
  cta: Schema.optional(Schema.String.annotations({ description: "Text to be displayed on the CTA button" }))
}).annotations({ description: "Text to be displayed on the card" })),
  top_right_badge: Schema.optional(PersonaBadgeSchema),
  suggestions: Schema.optional(Schema.Array(TopicRowItemSchema).annotations({ description: "List of pre-defined topics to initiate a call" })),
  status: Schema.optional(Schema.String.annotations({ description: "Availability status of the bot. See `InstructorAvailabilityStatus` for available statuses." })),
  redirect_urls: Schema.optional(Schema.Struct({
  card: Schema.optional(Schema.String.annotations({ description: "URL to redirect to when the card is clicked" })),
  cta: Schema.optional(Schema.String.annotations({ description: "URL to redirect to when the CTA button is clicked" })),
  chat_cta: Schema.optional(Schema.String.annotations({ description: "URL to redirect to when the CTA chat button is clicked" }))
}).annotations({ description: "List of URLs to redirect to" })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the instructor card row" }))
}).annotations({ description: "This row contains the details for the instructor card" })
const AdditionalContentRowItemSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title of the tile" })),
  subtitle_html: Schema.optional(Schema.String.annotations({ description: "Subtitle of the tile" }))
}).annotations({ description: "Container for text attributes" })),
  images: Schema.optional(Schema.Struct({
  background_1x1: Schema.optional(ImageResourceSchema),
  instructor_1x1: Schema.optional(ImageResourceSchema),
  arrow_icon_1x1: Schema.optional(ImageResourceSchema)
}).annotations({ description: "Container for image attributes" })),
  redirect_urls: Schema.optional(Schema.Struct({
  cta: Schema.optional(Schema.String.annotations({ description: "URL to redirect to when the CTA button is clicked" }))
}).annotations({ description: "URLs to redirect to" })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the additional content row" }))
}).annotations({ description: "This row contains the additional content tiles like recipe etc." })
const PersonaRowSchema = Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Row title (use header.text.title instead)" })),
  header: Schema.optional(PersonaRowHeaderSchema),
  type: Schema.optional(Schema.String.annotations({ description: "See `PersonaRowType` for available types." })),
  text_row_item: Schema.optional(TextRowItemSchema),
  text_column_row_items: Schema.optional(Schema.Array(TextColumnRowItemSchema).annotations({ description: "This row contains text to be displayed in a column" })),
  contacts_row_items: Schema.optional(Schema.Array(ContactRowItemSchema).annotations({ description: "This row displays a list of contacts" })),
  topic_row_items: Schema.optional(Schema.Array(TopicRowItemSchema).annotations({ description: "This row displays a list of topics to initiate a call" })),
  pill_row_items: Schema.optional(Schema.Array(PillRowItemSchema).annotations({ description: "This row displays a list of pills" })),
  instructor_list_row_items: Schema.optional(Schema.Array(InstructorCardRowItemSchema).annotations({ description: "This row displays a list of instructor cards to start a call" })),
  additional_content_row_items: Schema.optional(Schema.Array(AdditionalContentRowItemSchema).annotations({ description: "This row displays a list of instructor cards to start a call" })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the row" }))
})
const BioPageResponseSchema = Schema.Struct({
  banner: BannerSchema,
  redirect_urls: Schema.optional(Schema.Struct({
  cta: Schema.optional(Schema.String.annotations({ description: "URL to redirect to when the CTA button is clicked" })),
  chat_cta: Schema.optional(Schema.String.annotations({ description: "URL to redirect to when the CTA chat button is clicked" }))
}).annotations({ description: "URLs to redirect to" })),
  text: Schema.Struct({
  cta: Schema.String.annotations({ description: "Text to be displayed on the CTA button" })
}).annotations({ description: "Lists of text items to be displayed on the bio page" }),
  rows: Schema.Array(PersonaRowSchema).annotations({ description: "List of rows to be displayed on the bio page. See `PersonaRow.Type` for available rows." })
})
const HomepageResponseSchema = Schema.Struct({
  banner: BannerSchema,
  rows: Schema.Array(PersonaRowSchema).annotations({ description: "List of rows to be displayed on the homepage" }),
  show_coach_banner: Schema.optional(Schema.Boolean.annotations({ description: "Whether to show the coach banner for this user" }))
})
const FeedbackOptionSchema = Schema.Struct({
  id: Schema.String.annotations({ description: "Option ID" }),
  text: Schema.String.annotations({ description: "Option text" })
})
const FeedbackResponseSchema = Schema.Struct({
  possible_options: Schema.optional(Schema.Array(FeedbackOptionSchema).annotations({ description: "Lists all the possible feedback options" }))
})
const ConversationCreateRequestSchema = Schema.Struct({
  origin: Schema.optional(Schema.String.annotations({ description: "conversation origin from" })),
  uuid: Schema.String.annotations({ description: "uuid of the conversation" }),
  "@timestamp": Schema.String.annotations({ description: "Timestamp of the message" }),
  user_id: Schema.String.annotations({ description: "conversation user_id" }),
  instructor_id: Schema.String.annotations({ description: "instructor name" }),
  model_id: Schema.String.annotations({ description: "model_id" })
})
const ConversationMessageSchema = Schema.Struct({
  role: Schema.String.annotations({ description: "Role of the sender" }),
  content: Schema.String.annotations({ description: "Content of the message" }),
  uuid: Schema.String.annotations({ description: "The UUID of the message" }),
  turn: Schema.Number.annotations({ description: "Turn number of the message in the conversation" }),
  kind: Schema.String.annotations({ description: "Kind of message (e.g., \"text\", \"voice\")" }),
  "@timestamp": Schema.String.annotations({ description: "Timestamp of the message" })
})
const ConversationSchema = Schema.Struct({
  uuid: Schema.String.annotations({ description: "The UUID of the conversation" }),
  "@timestamp": Schema.String.annotations({ description: "Timestamp of the conversation" }),
  user_id: Schema.String.annotations({ description: "User ID associated with the conversation" }),
  instructor_id: Schema.String.annotations({ description: "Instructor ID associated with the conversation" }),
  model_id: Schema.String.annotations({ description: "Model ID used in the conversation" }),
  messages: Schema.Array(ConversationMessageSchema).annotations({ description: "List of messages in the conversation" }),
  kind: Schema.optional(Schema.String.annotations({ description: "Type of conversation (e.g., \"voice\", \"text\")" })),
  origin: Schema.optional(Schema.String.annotations({ description: "Origin of the conversation (e.g., \"web\", \"mobile\")" }))
})
const ConversationUpdateRequestSchema = Schema.Struct({
  origin: Schema.String.annotations({ description: "conversation origin from" })
})
const ConversationAddMessageRequestSchema = Schema.Struct({
  "@timestamp": Schema.String.annotations({ description: "Timestamp of the message" }),
  uuid: Schema.optional(Schema.String.annotations({ description: "UUID of the message" })),
  role: Schema.String.annotations({ description: "Role of the sender" }),
  thoughts: Schema.String.annotations({ description: "Thoughts of the sender" }),
  turnId: Schema.String.annotations({ description: "Turn ID of the conversation" }),
  systemPrompt: Schema.String.annotations({ description: "System prompt" }),
  duration: Schema.optional(Schema.Number.annotations({ description: "Duration of the audio in milliseconds" })),
  thinkingDuration: Schema.optional(Schema.Number.annotations({ description: "Duration of the user thinking in milliseconds" })),
  conversation: ConversationCreateRequestSchema
})
const MessageSchema = Schema.Struct({
  uuid: Schema.String.annotations({ description: "The UUID of the message" })
})
const SilentCoachMessageSchema = Schema.Struct({
  speaker: Schema.optional(Schema.String.annotations({ description: "Speaker of the message" })),
  transcript: Schema.optional(Schema.String),
  start_time: Schema.optional(Schema.Number.annotations({ description: "Timestamp when this message turn started (seconds since conversation start)" })),
  end_time: Schema.optional(Schema.Number.annotations({ description: "Timestamp when this message turn ended (seconds since conversation start)" }))
})
const ConversationFinishRequestSchema = Schema.Struct({
  messages: Schema.optional(Schema.Array(SilentCoachMessageSchema)),
  user_uuid: Schema.optional(Schema.String)
})
const ContentCategorySchema = Schema.Struct({
  uuid: Schema.String.annotations({ description: "Content Category UUID" }),
  text: Schema.Struct({
  title: Schema.String.annotations({ description: "Content Category Title" })
}),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the content category" }))
})
const ContentCategoriesResponseSchema = Schema.Struct({
  categories: Schema.optional(Schema.Array(ContentCategorySchema))
})
const ImageTitleContentItemSchema = Schema.Struct({
  text: Schema.Struct({
  title: Schema.String.annotations({ description: "Content Title" })
}),
  redirect_url: Schema.optional(Schema.String.annotations({ description: "URL to redirect to when the content item is clicked" })),
  images: Schema.optional(Schema.Struct({
  content_1x1: Schema.optional(ImageResourceSchema),
  icon: Schema.optional(ImageResourceSchema)
})),
  background_color: Schema.optional(Schema.String.annotations({ description: "Background color in hex format of the tile if there is no image available (eg. techniques)" })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the content preview" }))
})
const ContentItemSchema = Schema.Struct({
  uuid: Schema.optional(Schema.String.annotations({ description: "Content UUID of the item." })),
  type: Schema.optional(Schema.String.annotations({ description: "See `ContentItemType` for available types." })),
  image_title_content_item: Schema.optional(ImageTitleContentItemSchema)
})
const ContentsResponseSchema = Schema.Struct({
  items: Schema.Array(ContentItemSchema),
  total_items: Schema.optional(Schema.Number.annotations({ description: "Indicates total number of items" }))
})
const RecipeIngredientsSectionSchema = Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Recipe ingredient title" })),
  items: Schema.Array(Schema.String).annotations({ description: "Recipe ingredient list" })
})
const RecipeInstructionSchema = Schema.Struct({
  title: Schema.String.annotations({ description: "Instruction title (optional in case there is just one instruction overall and we want to skip it)" }),
  body: Schema.String.annotations({ description: "Instruction body" })
})
const RecipeInstructionSectionSchema = Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Instruction Section title" })),
  body: Schema.optional(Schema.String.annotations({ description: "Instruction body" })),
  items: Schema.optional(Schema.Array(RecipeInstructionSchema).annotations({ description: "Instruction list" }))
})
const RecipeVariationSchema = Schema.Struct({
  title: Schema.String.annotations({ description: "Variation title" }),
  serving_size: Schema.optional(Schema.String.annotations({ description: "Variation serving size" })),
  description: Schema.String.annotations({ description: "Variation description" }),
  instructions: Schema.optional(Schema.Array(Schema.String).annotations({ description: "Variation instructions" })),
  ingredients: Schema.optional(Schema.Array(Schema.String).annotations({ description: "Variation ingredients" })),
  image: Schema.optional(ImageResourceSchema)
})
const RecipeContentSchema = Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Recipe title" })),
  background_image_1x1: Schema.optional(ImageResourceSchema),
  categories: Schema.optional(Schema.Array(Schema.String).annotations({ description: "Categories a recipe belongs to" })),
  serving_size: Schema.optional(Schema.String.annotations({ description: "Serving size" })),
  ctas: Schema.optional(Schema.Struct({
  cta: Schema.Struct({
  title: Schema.String.annotations({ description: "CTA title to be displayed" }),
  url: Schema.String.annotations({ description: "CTA URL to be redirected to" })
}).annotations({ description: "CTA for the recipe" }),
  chat_cta: Schema.optional(Schema.Struct({
  title: Schema.String.annotations({ description: "CTA title to be displayed" }),
  url: Schema.String.annotations({ description: "CTA URL to be redirected to" })
}).annotations({ description: "CTA for the recipe" }))
}).annotations({ description: "CTAs for the recipe" })),
  description: Schema.optional(Schema.String.annotations({ description: "Brief description of the recipe" })),
  ingredients: Schema.optional(Schema.Array(RecipeIngredientsSectionSchema).annotations({ description: "Sectioned ingredients for the recipe" })),
  instructions: Schema.optional(Schema.Array(RecipeInstructionSectionSchema).annotations({ description: "Sectioned steps and how-tos" })),
  variations: Schema.optional(Schema.Array(RecipeVariationSchema).annotations({ description: "Recipe variations" })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the recipe" }))
})
const ContentDetailSchema = Schema.Struct({
  uuid: Schema.optional(Schema.String.annotations({ description: "Content UUID" })),
  content_token: Schema.optional(Schema.String.annotations({ description: "JWT token for cortex" })),
  recipe_content: Schema.optional(RecipeContentSchema)
})
const ContentHistoryItemSchema = Schema.Struct({
  interacted_at: Schema.optional(Schema.String.annotations({ description: "The timestamp when the user interacted with the content." })),
  content_item: Schema.optional(ContentItemSchema)
})
const ContentHistoryResponseSchema = Schema.Struct({
  content_history: Schema.optional(Schema.Array(ContentHistoryItemSchema)),
  total_items: Schema.optional(Schema.Number.annotations({ description: "Indicates total number of items" }))
})
const ContentHistoryUpdateRequestSchema = Schema.Struct({
  content_uuids: Schema.optional(Schema.Array(Schema.String))
})
const CheckEmailResponseSchema = Schema.Struct({
  identity_providers: Schema.optional(Schema.Array(Schema.String.annotations({ description: "The identity providers associated with the email. Use `IdentityProviderType` enum for a list of possible values.
" })))
})
const AppleSubscriptionConfirmResponseSchema = Schema.Struct({
  analytics: Schema.optional(Schema.Struct({}))
})
const RoleplayHomepageHeaderInfoSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Main title for the roleplay homepage" }))
}))
})
const RoleplayUserScoreSchema = Schema.Struct({
  percentage: Schema.optional(Schema.Number.annotations({ description: "User Score as a percentage" })),
  text: Schema.optional(Schema.String.annotations({ description: "Score as text" })),
  title: Schema.optional(Schema.String.annotations({ description: "Title for the score" }))
})
const RoleplayHomepageUserScoresInfoSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title for the user scores section" }))
})),
  user_scores: Schema.optional(Schema.Array(RoleplayUserScoreSchema)),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the user scores row" }))
})
const RoleplayCategorySchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Category title" })),
  badge: Schema.optional(Schema.String.annotations({ description: "Category badge" }))
})),
  uuid: Schema.optional(Schema.String.annotations({ description: "Category UUID" })),
  slug: Schema.optional(Schema.String.annotations({ description: "Category slug" })),
  images: Schema.optional(Schema.Struct({
  leading_image_1x1: Schema.optional(ImageResourceSchema)
})),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the category" }))
})
const RoleplaySubCategoryFilterSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title for the sub category filter" }))
})),
  slug: Schema.optional(Schema.String.annotations({ description: "Slug for the sub category filter" })),
  uuid: Schema.optional(Schema.String.annotations({ description: "UUID for the sub category filter (this will be null for the 'all' filter)" })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the sub category filter" }))
})
const RoleplayScenarioSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Scenario title" })),
  subtitle: Schema.optional(Schema.String.annotations({ description: "Scenario subtitle" })),
  caption: Schema.optional(Schema.String.annotations({ description: "Scenario caption" })),
  number: Schema.optional(Schema.String.annotations({ description: "Scenario number" })),
  feedback: Schema.optional(Schema.String.annotations({ description: "Feedback for the scenario" }))
})),
  uuid: Schema.optional(Schema.String.annotations({ description: "Scenario UUID" })),
  slug: Schema.optional(Schema.String.annotations({ description: "Scenario slug" })),
  user_score: Schema.optional(RoleplayUserScoreSchema),
  cta: Schema.optional(Schema.Struct({
  url: Schema.optional(Schema.String.annotations({ description: "CTA URL to be redirected to" }))
})),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the scenario" }))
})
const RoleplaySubCategorySchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  caption: Schema.optional(Schema.String.annotations({ description: "Sub-category caption" })),
  title: Schema.optional(Schema.String.annotations({ description: "Sub-category title" })),
  footer: Schema.optional(Schema.String.annotations({ description: "Sub-category footer text" }))
})),
  uuid: Schema.optional(Schema.String.annotations({ description: "Sub-category UUID" })),
  slug: Schema.optional(Schema.String.annotations({ description: "Sub-category slug" })),
  is_available: Schema.optional(Schema.Boolean.annotations({ description: "Whether the sub-category is available" })),
  scenarios: Schema.optional(Schema.Array(RoleplayScenarioSchema)),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the sub-category" }))
})
const RoleplayHomepageSelectedSubCategoriesInfoSchema = Schema.Struct({
  sub_categories: Schema.optional(Schema.Array(RoleplaySubCategorySchema))
})
const RoleplayHomepageCategoriesInfoSchema = Schema.Struct({
  selected_category_uuid: Schema.optional(Schema.String.annotations({ description: "UUID of the currently selected category" })),
  selected_category_slug: Schema.optional(Schema.String.annotations({ description: "Slug of the currently selected category" })),
  selected_sub_category_filter_slug: Schema.optional(Schema.String.annotations({ description: "Slug of the currently selected sub category filter" })),
  categories: Schema.optional(Schema.Array(RoleplayCategorySchema)),
  sub_category_filters: Schema.optional(Schema.Array(RoleplaySubCategoryFilterSchema)),
  selected_sub_categories_info: Schema.optional(RoleplayHomepageSelectedSubCategoriesInfoSchema),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the categories" }))
})
const RoleplayHomepageResponseSchema = Schema.Struct({
  header_info: Schema.optional(RoleplayHomepageHeaderInfoSchema),
  user_scores_info: Schema.optional(RoleplayHomepageUserScoresInfoSchema),
  categories_info: Schema.optional(RoleplayHomepageCategoriesInfoSchema),
  show_coach_banner: Schema.optional(Schema.Boolean.annotations({ description: "Whether to show the coach banner for this user" }))
})
const RoleplayCtaSchema = Schema.Struct({
  label: Schema.optional(Schema.String.annotations({ description: "The label displayed on the call-to-action (CTA) button." })),
  url: Schema.optional(Schema.String.annotations({ description: "Destination URL for the CTA. Can be an absolute or relative path." })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the user status" }))
})
const HomepageForYouWhatsNewItemSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title for the item" })),
  subtitle: Schema.optional(Schema.String.annotations({ description: "Subtitle for the item" }))
})),
  ctas: Schema.optional(Schema.Struct({
  card: Schema.optional(RoleplayCtaSchema)
})),
  images: Schema.optional(Schema.Struct({
  leading_image_1x1: Schema.optional(ImageResourceSchema)
})),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the whats new item" }))
})
const HomepageForYouWhatsNewSectionSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title for the section" }))
})),
  items: Schema.optional(Schema.Array(HomepageForYouWhatsNewItemSchema)),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the whats new section" }))
})
const HomepageForYouCallCoachSchema = Schema.Struct({
  images: Schema.optional(Schema.Struct({
  instructor_1x1: Schema.optional(ImageResourceSchema)
}).annotations({ description: "Image to displayed on the tile" })),
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Name of the instructor" }))
}).annotations({ description: "Text to be displayed on the tile" })),
  ctas: Schema.optional(Schema.Struct({
  card: Schema.optional(RoleplayCtaSchema),
  call: Schema.optional(RoleplayCtaSchema),
  chat_cta: Schema.optional(RoleplayCtaSchema)
}).annotations({ description: "URLs to redirect to" })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the user status" }))
})
const HomepageForYouCallCoachesSectionSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title for the row" })),
  subtitle: Schema.optional(Schema.String.annotations({ description: "Subtitle for the row" }))
})),
  items: Schema.optional(Schema.Array(HomepageForYouCallCoachSchema)),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the user status" }))
})
const HomepageForYouUserStatusSectionSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title for the section" }))
})),
  user_scores: Schema.optional(Schema.Array(RoleplayUserScoreSchema)),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the user status" }))
})
const HomepageForYouDailyChallengeRowSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title for the row" }))
})),
  items: Schema.optional(Schema.Array(RoleplayScenarioSchema)),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the user status" }))
})
const HomepageForYouEssentialPathRowSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title for the row" }))
})),
  items: Schema.optional(Schema.Array(RoleplayScenarioSchema)),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the user status" }))
})
const HomepageForYouCustomRoleplayRowSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title for the row" }))
})),
  items: Schema.optional(Schema.Array(RoleplayScenarioSchema)),
  ctas: Schema.optional(Schema.Struct({
  see_all: Schema.optional(Schema.String.annotations({ description: "URL to redirect to" }))
}).annotations({ description: "URLs to redirect to" })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the user status" }))
})
const HomepageForYouRoleplayRowSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title for the row" }))
})),
  items: Schema.optional(Schema.Array(RoleplayScenarioSchema)),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the user status" }))
})
const HomepageForYouRoleplaysSectionsSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title for the section" })),
  subtitle: Schema.optional(Schema.String.annotations({ description: "Subtitle for the section" }))
})),
  user_score_section: Schema.optional(HomepageForYouUserStatusSectionSchema),
  daily_challenge_section: Schema.optional(HomepageForYouDailyChallengeRowSchema),
  essential_path_section: Schema.optional(HomepageForYouEssentialPathRowSchema),
  custom_roleplay_section: Schema.optional(HomepageForYouCustomRoleplayRowSchema),
  items: Schema.optional(Schema.Array(HomepageForYouRoleplayRowSchema))
})
const HomepageForYouResponseSchema = Schema.Struct({
  whats_new_section: Schema.optional(HomepageForYouWhatsNewSectionSchema),
  call_coaches_section: Schema.optional(HomepageForYouCallCoachesSectionSchema),
  roleplays_sections: Schema.optional(HomepageForYouRoleplaysSectionsSchema),
  show_coach_banner: Schema.optional(Schema.Boolean.annotations({ description: "Whether to show the coach banner for this user" }))
})
const TextMessageResponseSchema = Schema.Struct({
  body: Schema.String,
  uuid: Schema.optional(Schema.String),
  created_at: Schema.optional(Schema.String),
  is_flagged_by_moderation: Schema.optional(Schema.Boolean),
  author: Schema.optional(Schema.Struct({
  name: Schema.String,
  avatar_url_1x1: Schema.optional(Schema.String),
  is_bot: Schema.Boolean
}))
})
const ListContentsResponseSchema = Schema.Struct({
  items: Schema.Array(Schema.String),
  title: Schema.String
})
const MessageResponseSchema = Schema.Struct({
  uuid: Schema.String,
  created_at: Schema.String,
  author: Schema.Struct({
  name: Schema.String,
  avatar_url_1x1: Schema.optional(Schema.String),
  is_bot: Schema.Boolean
}),
  content_type: Schema.String.annotations({ description: "See `MessageContentType` for available types." }),
  text_content: Schema.optional(TextMessageResponseSchema),
  list_content: Schema.optional(ListContentsResponseSchema),
  analytics: Schema.optional(Schema.Struct({}))
})
const CursorSchema = Schema.Struct({
  next_cursor: Schema.optional(Schema.String)
})
const CreateTextMessageSchema = Schema.Struct({
  content: Schema.String
})
const CreateSetContentMessageSchema = Schema.Struct({
  content_uuid: Schema.String
})
const CreateMessageRequestBodySchema = Schema.Struct({
  content_type: Schema.String.annotations({ description: "See `MessageCreationContentType` for available types." }),
  conversation_uuid: Schema.String,
  fake_message: Schema.optional(Schema.Boolean),
  cpt: Schema.optional(Schema.Boolean.annotations({ description: "feature flip for CPT model" })),
  text_content: Schema.optional(CreateTextMessageSchema),
  set_content: Schema.optional(CreateSetContentMessageSchema)
})
const RoleplayDetailTipSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String)
}))
})
const RoleplayDetailPreviousFeedbackSchema = Schema.Struct({
  conversation_uuid: Schema.optional(Schema.String.annotations({ description: "Conversation UUID" })),
  user_score: Schema.optional(RoleplayUserScoreSchema),
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String),
  subtitle: Schema.optional(Schema.String)
})),
  cta: Schema.optional(Schema.Struct({
  card: Schema.optional(Schema.String.annotations({ description: "Feedback CTA URL to be redirected to" }))
})),
  analytics: Schema.optional(Schema.Struct({}))
})
const RoleplayDetailAiRoleSchema = Schema.Struct({
  slug: Schema.optional(Schema.String),
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String)
}))
})
const RoleplayDetailAiPersonalitySchema = Schema.Struct({
  slug: Schema.optional(Schema.String),
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String),
  subtitle: Schema.optional(Schema.String)
})),
  is_default: Schema.optional(Schema.Boolean)
})
const RoleplayDetailAiVoiceStyleSchema = Schema.Struct({
  slug: Schema.optional(Schema.String),
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String)
}))
})
const RoleplayDetailResponseSchema = Schema.Struct({
  analytics: Schema.optional(Schema.Struct({})),
  tips: Schema.optional(Schema.Array(RoleplayDetailTipSchema)),
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String)
})),
  previous_feedback_info: Schema.optional(Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String)
})),
  items: Schema.optional(Schema.Array(RoleplayDetailPreviousFeedbackSchema))
})),
  roleplay_form_info: Schema.optional(Schema.Struct({
  ai_role: Schema.optional(Schema.Struct({
  roles: Schema.optional(Schema.Array(RoleplayDetailAiRoleSchema))
})),
  ai_personality: Schema.optional(Schema.Struct({
  personalities: Schema.optional(Schema.Array(RoleplayDetailAiPersonalitySchema))
})),
  ai_voice_style: Schema.optional(Schema.Struct({
  voice_styles: Schema.optional(Schema.Array(RoleplayDetailAiVoiceStyleSchema))
}))
}))
})
const RoleplayCreateRequestSchema = Schema.Struct({
  roleplay_scenario: Schema.optional(Schema.Struct({
  scenario_description: Schema.optional(Schema.String.annotations({ description: "Description of the roleplay scenario" })),
  scenario_uuid_or_slug: Schema.optional(Schema.String.annotations({ description: "UUID or slug of a pre-defined scenario (optional if creating a custom scenario)" })),
  scenario_name: Schema.optional(Schema.String.annotations({ description: "Name of the roleplay scenario" })),
  ai_role_slug: Schema.optional(Schema.String.annotations({ description: "slug of the AI role" })),
  ai_personality_slug: Schema.optional(Schema.String.annotations({ description: "slug of the AI personality" })),
  ai_voice_style_uuid_or_slug: Schema.optional(Schema.String.annotations({ description: "UUID or slug of the AI voice style" })),
  ai_name: Schema.optional(Schema.String.annotations({ description: "Name of the AI character" })),
  additional_context: Schema.optional(Schema.String.annotations({ description: "Additional context for the roleplay scenario" }))
})),
  retry_scenario: Schema.optional(Schema.Struct({
  conversation_uuid: Schema.optional(Schema.String.annotations({ description: "Previous conversation settings to retry" }))
}))
})
const RoleplayCreateResponseSchema = Schema.Struct({
  user_roleplay_uuid: Schema.optional(Schema.String.annotations({ description: "UUID of the created roleplay session" })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the roleplay session" })),
  error: Schema.optional(Schema.Struct({
  code: Schema.optional(Schema.String.annotations({ description: "This error code would be of type `RoleplayCreateErrorCode`" })),
  message: Schema.optional(Schema.String)
}))
})
const RoleplayFeedbackCtaSchema = Schema.Struct({
  title: Schema.optional(Schema.String),
  url: Schema.optional(Schema.String),
  analytics: Schema.optional(Schema.Struct({}))
})
const RoleplayFeedbackQuoteItemSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  description: Schema.optional(Schema.String),
  quote: Schema.optional(Schema.String),
  explanation: Schema.optional(Schema.String)
})),
  analytics: Schema.optional(Schema.Struct({}))
})
const RoleplayFeedbackBulletItemSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String),
  subtitle: Schema.optional(Schema.String)
})),
  image_type: Schema.optional(Schema.String.annotations({ description: "The image to display for the bullet item. See `RoleplayFeedbackBulletImageType` for available types" })),
  analytics: Schema.optional(Schema.Struct({}))
})
const RoleplayFeedbackNumberedItemSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String),
  subtitle: Schema.optional(Schema.String)
})),
  badge: Schema.optional(Schema.String),
  analytics: Schema.optional(Schema.Struct({}))
})
const RoleplayFeedbackDebriefItemSchema = Schema.Struct({
  images: Schema.optional(Schema.Struct({
  instructor_1x1: Schema.optional(ImageResourceSchema)
}).annotations({ description: "Image to displayed on the tile" })),
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Name of the instructor (bot)" })),
  subtitle: Schema.optional(Schema.String.annotations({ description: "Subtitle of the tile" }))
}).annotations({ description: "Text to be displayed on the tile" })),
  ctas: Schema.optional(Schema.Struct({
  call: Schema.optional(RoleplayFeedbackCtaSchema)
}).annotations({ description: "URLs to redirect to" })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the tile" }))
})
const RoleplayFeedbackSpeechMetricItemSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String),
  subtitle: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String),
  rating: Schema.optional(Schema.String)
})),
  analytics: Schema.optional(Schema.Struct({}))
})
const RoleplayFeedbackScorecardItemSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String),
  subtitle: Schema.optional(Schema.String),
  value: Schema.optional(Schema.String)
})),
  analytics: Schema.optional(Schema.Struct({}))
})
const RoleplayFeedbackSectionSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String)
})),
  type: Schema.optional(Schema.String.annotations({ description: "See `RoleplayFeedbackSectionType` for a list of values." })),
  try_next_scenario_items: Schema.optional(Schema.Array(RoleplayScenarioSchema)),
  quote_items: Schema.optional(Schema.Array(RoleplayFeedbackQuoteItemSchema)),
  bullet_items: Schema.optional(Schema.Array(RoleplayFeedbackBulletItemSchema)),
  next_time_consider_items: Schema.optional(Schema.Array(RoleplayFeedbackBulletItemSchema)),
  numbered_items: Schema.optional(Schema.Array(RoleplayFeedbackNumberedItemSchema)),
  debrief_items: Schema.optional(Schema.Array(RoleplayFeedbackDebriefItemSchema)),
  speech_metric_items: Schema.optional(Schema.Array(RoleplayFeedbackSpeechMetricItemSchema)),
  scorecard_items: Schema.optional(Schema.Array(RoleplayFeedbackScorecardItemSchema)),
  images: Schema.optional(Schema.Struct({
  top_right_icon: Schema.optional(ImageResourceSchema)
})),
  analytics: Schema.optional(Schema.Struct({}))
})
const RoleplayFeedbackResponseSchema = Schema.Struct({
  status: Schema.optional(Schema.String.annotations({ description: "See 'RoleplayFeedbackStatus'" })),
  follow_up_conversation_uuid: Schema.optional(Schema.String),
  ctas: Schema.optional(Schema.Struct({
  header: Schema.optional(Schema.Struct({
  retry_cta: Schema.optional(RoleplayFeedbackCtaSchema),
  done_cta: Schema.optional(RoleplayFeedbackCtaSchema)
})),
  footer: Schema.optional(Schema.Struct({
  retry_cta: Schema.optional(RoleplayFeedbackCtaSchema),
  done_cta: Schema.optional(RoleplayFeedbackCtaSchema)
}))
}).annotations({ description: "CTAs for the feedback page" })),
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String)
})),
  user_score: Schema.optional(RoleplayUserScoreSchema),
  feedback_sections: Schema.optional(Schema.Array(RoleplayFeedbackSectionSchema)),
  analytics: Schema.optional(Schema.Struct({})),
  error: Schema.optional(Schema.Struct({
  code: Schema.optional(Schema.String.annotations({ description: "This error code would be of type `RoleplayFeedbackErrorCode`" })),
  message: Schema.optional(Schema.String)
}))
})
const PrePaywallAmaTopicSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "AMA Topic" }))
})),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the scenario" }))
})
const RoleplayTestimonialSchema = Schema.Struct({
  testimonial: Schema.optional(Schema.String.annotations({ description: "Testimonial text" })),
  author: Schema.optional(Schema.String.annotations({ description: "Testimonial author" }))
})
const PrePaywallIconWithTitleSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  label: Schema.optional(Schema.String.annotations({ description: "Title text" }))
})),
  icon: Schema.optional(ImageResourceSchema)
})
const PrePaywallSkillsItemArraySchema = Schema.Array(PrePaywallIconWithTitleSchema)
const PrePaywallControlsItemArraySchema = Schema.Array(PrePaywallIconWithTitleSchema)
const PrePaywallCategoryInfoSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  name: Schema.optional(Schema.String.annotations({ description: "Category name" })),
  title: Schema.optional(Schema.String.annotations({ description: "Header text for the category" })),
  subtitle: Schema.optional(Schema.String.annotations({ description: "Subtitle text for the category" }))
})),
  images: Schema.optional(Schema.Struct({
  header: Schema.optional(ImageResourceSchema)
}).annotations({ description: "Image to displayed on the topic card" })),
  instructor_slugs: Schema.optional(Schema.Array(Schema.String).annotations({ description: "Slugs of instructors in this category that the client needs to filter" })),
  skills: Schema.optional(Schema.Struct({
  items: Schema.optional(PrePaywallSkillsItemArraySchema)
})),
  controls: Schema.optional(Schema.Struct({
  items: Schema.optional(PrePaywallControlsItemArraySchema)
}))
})
const RoleplayInstructorTopicSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Topic title" }))
})),
  audio_file_url: Schema.optional(Schema.String.annotations({ description: "URL to the audio file for this topic" })),
  is_available: Schema.optional(Schema.Boolean.annotations({ description: "Whether the topic is available" }))
})
const RoleplayInstructorSchema = Schema.Struct({
  uuid: Schema.optional(Schema.String.annotations({ description: "Instructor UUID" })),
  slug: Schema.optional(Schema.String.annotations({ description: "Instructor slug" })),
  images: Schema.optional(Schema.Struct({
  background: Schema.optional(ImageResourceSchema),
  profile: Schema.optional(ImageResourceSchema)
})),
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Instructor name" })),
  caption: Schema.optional(Schema.String.annotations({ description: "Instructor caption" })),
  areas_of_expertise: Schema.optional(Schema.Array(Schema.String))
})),
  ctas: Schema.optional(Schema.Struct({
  card: Schema.optional(Schema.String)
})),
  topics: Schema.optional(Schema.Array(RoleplayInstructorTopicSchema)),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the instructor" }))
})
const PrePaywallCategorySchema = Schema.Struct({
  uuid: Schema.optional(Schema.String.annotations({ description: "Category UUID" })),
  slug: Schema.optional(Schema.String.annotations({ description: "Category slug" })),
  cta: Schema.optional(Schema.Struct({
  card: Schema.optional(Schema.String.annotations({ description: "CTA URL to be redirected to" }))
})),
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Category Title" })),
  caption: Schema.optional(Schema.String.annotations({ description: "Category Caption" }))
})),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the category" }))
})
const BrowseCategoriesListSchema = Schema.Array(PrePaywallCategorySchema).annotations({ description: "List of categories for browsing" })
const PrePaywallStatisticSchema = Schema.Struct({
  value: Schema.optional(Schema.String.annotations({ description: "The statistical value (e.g., \"5x\", \"93%\", \"78%\")" })),
  label: Schema.optional(Schema.String.annotations({ description: "Description of what the statistic represents" })),
  description: Schema.optional(Schema.String.annotations({ description: "Additional descriptive text for the statistic" }))
}).annotations({ description: "Statistical data point with value and description" })
const PrePaywallTopicCardSchema = Schema.Struct({
  icon: Schema.optional(ImageResourceSchema),
  title: Schema.optional(Schema.String.annotations({ description: "Title of the topic/skill" })),
  description: Schema.optional(Schema.String.annotations({ description: "Description of the topic/skill" }))
}).annotations({ description: "Topic/skill card with icon, title and description" })
const PrePaywallCategoryResponseSchema = Schema.Struct({
  ama_topics: Schema.optional(Schema.Array(PrePaywallAmaTopicSchema).annotations({ description: "A random selection of 80 topics from all coaches" })),
  testimonials: Schema.optional(Schema.Array(RoleplayTestimonialSchema)),
  sub_categories: Schema.optional(Schema.Array(RoleplaySubCategorySchema)),
  category_info: Schema.optional(PrePaywallCategoryInfoSchema),
  instructors: Schema.optional(Schema.Array(RoleplayInstructorSchema)),
  other_categories: Schema.optional(Schema.Array(PrePaywallCategorySchema)),
  browse_categories: Schema.optional(BrowseCategoriesListSchema),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data" })),
  statistics: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title for the statistics section" })),
  subtitle: Schema.optional(Schema.String.annotations({ description: "Subtitle for the statistics section" })),
  items: Schema.optional(Schema.Array(PrePaywallStatisticSchema).annotations({ description: "Statistical data and benefits to display to users" }))
}).annotations({ description: "Statistics section with title and data" })),
  topic_cards: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title for the topic cards section" })),
  subtitle: Schema.optional(Schema.String.annotations({ description: "Subtitle for the topic cards section" })),
  items: Schema.optional(Schema.Array(PrePaywallTopicCardSchema).annotations({ description: "Topic/skill cards with icons, titles and descriptions" }))
}).annotations({ description: "Topic cards section with title and cards" }))
})
const RoleplayCategoryWithSubCategoriesSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Category title" })),
  caption: Schema.optional(Schema.String.annotations({ description: "Category caption" }))
})),
  uuid: Schema.optional(Schema.String.annotations({ description: "Category UUID" })),
  slug: Schema.optional(Schema.String.annotations({ description: "Category slug" })),
  cta: Schema.optional(Schema.Struct({
  card: Schema.optional(Schema.String.annotations({ description: "CTA URL to be redirected to" }))
})),
  sub_categories: Schema.optional(Schema.Array(RoleplaySubCategorySchema)),
  is_available: Schema.optional(Schema.Boolean.annotations({ description: "Whether the category is available" })),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data for the category" }))
})
const PrePaywallHomepageResponseSchema = Schema.Struct({
  ama_topics: Schema.optional(Schema.Array(PrePaywallAmaTopicSchema).annotations({ description: "A random selection of 80 topics from all coaches" })),
  testimonials: Schema.optional(Schema.Array(RoleplayTestimonialSchema)),
  categories: Schema.optional(Schema.Array(RoleplayCategoryWithSubCategoriesSchema)),
  instructors: Schema.optional(Schema.Array(RoleplayInstructorSchema)),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data" }))
})
const BrowseInstructorsListSchema = Schema.Array(RoleplayInstructorSchema).annotations({ description: "List of instructors for browsing" })
const PrePaywallBioResponseSchema = Schema.Struct({
  banner: Schema.optional(BannerSchema),
  rows: Schema.optional(Schema.Array(PersonaRowSchema).annotations({ description: "List of rows to be displayed on the bio page. See `PersonaRow.Type` for available rows." })),
  categories: Schema.optional(Schema.Array(RoleplayCategoryWithSubCategoriesSchema)),
  other_instructors: Schema.optional(Schema.Array(RoleplayInstructorSchema)),
  browse_instructors: Schema.optional(BrowseInstructorsListSchema),
  analytics: Schema.optional(Schema.Struct({}).annotations({ description: "Analytics data" }))
})
const CalendarEventSchema = Schema.Struct({
  id: Schema.String.annotations({ description: "Internal UUID of the calendar event record" }),
  title: Schema.String.annotations({ description: "The title/summary of the calendar event" }),
  start_at: Schema.String.annotations({ description: "Start time of the event (ISO 8601 format)" }),
  ends_at: Schema.String.annotations({ description: "End time of the event (ISO 8601 format)" }),
  entry_point_url: Schema.optional(Schema.Union(Schema.String.annotations({ description: "Primary video conference or meeting URL (e.g., Zoom, Google Meet).
Null if the event has no virtual meeting link.
" }), Schema.Null)),
  entry_point_type: Schema.optional(Schema.Union(Schema.Literal("zoom"), Schema.Literal("google_meet"), Schema.Literal("teams"), Schema.Literal("webex"), Schema.Literal("other")))
})
const CalendarEventsResponseSchema = Schema.Struct({
  events: Schema.Array(CalendarEventSchema).annotations({ description: "List of calendar events within the requested time window" })
})
const components-schemas-ErrorSchema = Schema.Struct({
  message: Schema.optional(Schema.String.annotations({ description: "A human-readable error message" })),
  code: Schema.optional(Schema.String.annotations({ description: "Machine-readable error code" }))
})
const AuthorizeCalendarRequestSchema = Schema.Struct({
  redirect_url: Schema.optional(Schema.String.annotations({ description: "Optional URL to redirect to after authorization completes.
If not provided, uses the default application redirect URL.
" }))
})
const AuthorizeCalendarResponseSchema = Schema.Struct({
  authorization_url: Schema.String.annotations({ description: "URL to redirect the user to for Google OAuth authorization.
After authorization, Google will redirect back to the application.
" }),
  state: Schema.optional(Schema.String.annotations({ description: "State parameter for OAuth flow security.
This should be stored and validated when the user returns.
" }))
})
const CalendarWebhookResponseSchema = Schema.Struct({
  status: Schema.optional(Schema.String)
})
const CoachCalendarMeetingSchema = Schema.Struct({
  uuid: Schema.optional(Schema.String.annotations({ description: "Unique identifier for the meeting" })),
  title: Schema.optional(Schema.String.annotations({ description: "Title of the meeting" })),
  start_at: Schema.optional(Schema.String.annotations({ description: "Start time of the meeting (ISO 8601 format)" })),
  ends_at: Schema.optional(Schema.String.annotations({ description: "End time of the meeting (ISO 8601 format)" })),
  cta: Schema.optional(Schema.String.annotations({ description: "URL for tapping into this meeting." })),
  meeting_url: Schema.optional(Schema.String.annotations({ description: "URL to join or view the meeting" })),
  analytics: Schema.optional(Schema.Struct({}))
})
const CoachCalendarResponseSchema = Schema.Struct({
  calendar_auth_status: Schema.optional(Schema.String.annotations({ description: "Status of the calendar authentication. Check CalendarAuthStatus for possible values." })),
  text: Schema.optional(Schema.Struct({
  header: Schema.optional(Schema.String.annotations({ description: "Header text for the calendar section" })),
  upcoming_meetings_title: Schema.optional(Schema.String.annotations({ description: "Title for the upcoming meetings section" }))
})),
  upcoming_meetings: Schema.optional(Schema.Array(CoachCalendarMeetingSchema))
})
const PreviousMeetingItemSchema = Schema.Struct({
  meeting_uuid: Schema.optional(Schema.String.annotations({ description: "Unique identifier for the meeting" })),
  conversation_uuid: Schema.optional(Schema.String.annotations({ description: "Unique identifier for the conversation" })),
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String),
  scheduled_at: Schema.optional(Schema.String.annotations({ description: "When the meeting was held" })),
  score: Schema.optional(Schema.Number)
})),
  cta: Schema.optional(Schema.String),
  analytics: Schema.optional(Schema.Struct({}))
})
const PreviousMeetingsResponseSchema = Schema.Struct({
  pagination_info: Schema.optional(Schema.Struct({
  total_items: Schema.optional(Schema.Number),
  page_size: Schema.optional(Schema.Number),
  current_page_number: Schema.optional(Schema.Number)
})),
  text: Schema.optional(Schema.Struct({
  header: Schema.optional(Schema.String.annotations({ description: "Header text for the calendar section" }))
})),
  meetings: Schema.optional(Schema.Array(PreviousMeetingItemSchema)),
  analytics: Schema.optional(Schema.Struct({}))
})
const MeetingsForNotificationsResponseSchema = Schema.Struct({
  meetings: Schema.optional(Schema.Array(CoachCalendarMeetingSchema)),
  analytics: Schema.optional(Schema.Struct({}))
})
const CoachConversationCreateRequestSchema = Schema.Struct({
  conversation_uuid: Schema.String.annotations({ description: "Unique identifier for the conversation" }),
  user_uuid: Schema.String.annotations({ description: "UUID of the user participating in the conversation" }),
  meeting_uuid: Schema.optional(Schema.String.annotations({ description: "Google Calendar event uuID (optional). If provided, must correspond to an existing CalendarEvent." })),
  started_at: Schema.String.annotations({ description: "ISO 8601 timestamp when the user's conversation session started" }),
  ended_at: Schema.String.annotations({ description: "ISO 8601 timestamp when the user's conversation session ended" }),
  messages: Schema.Array(SilentCoachMessageSchema).annotations({ description: "Transcript messages from the conversation" })
})
const SilenctCoachFeedbackHeaderSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String),
  summary: Schema.optional(Schema.String)
})),
  image: Schema.optional(Schema.Struct({
  leading_image_1x1: Schema.optional(ImageResourceSchema)
}))
})
const SilentCoachFeedbackScoreBreakdownItemSchema = Schema.Struct({
  text: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String),
  subtitle: Schema.optional(Schema.String),
  hover_text: Schema.optional(Schema.String),
  name: Schema.optional(Schema.String.annotations({ description: "Full name of the metric" })),
  description: Schema.optional(Schema.String.annotations({ description: "Target range or description for the metric" }))
})),
  rating: Schema.optional(Schema.String.annotations({ description: "See `SilentCoachFeedbackRating` for the possible values." }))
})
const SilentCoachFeedbackMetricsSchema = Schema.Struct({
  score: Schema.optional(Schema.Number),
  hover_text: Schema.optional(Schema.String),
  score_breakdown_items: Schema.optional(Schema.Array(SilentCoachFeedbackScoreBreakdownItemSchema))
})
const SilentCoachFeedbackTextItemSchema = Schema.Struct({
  title: Schema.optional(Schema.String),
  body: Schema.optional(Schema.String),
  description: Schema.optional(Schema.String.annotations({ description: "Description text shown below the score" }))
})
const SilentCoachKeyTakeawaySchema = Schema.Struct({
  title: Schema.optional(Schema.String.annotations({ description: "Title for the key takeaway tab" })),
  body: Schema.optional(Schema.String.annotations({ description: "Main feedback text for key takeaway" })),
  action_item: Schema.optional(Schema.Struct({
  title: Schema.optional(Schema.String),
  body: Schema.optional(Schema.String)
}))
})
const SilentCoachFeedbackSkillBreakdownItemSchema = Schema.Struct({
  title: Schema.optional(Schema.String),
  score: Schema.optional(Schema.Number),
  description: Schema.optional(Schema.String)
})
const SilentCoachFeedbackSkillItemSchema = Schema.Struct({
  current_meeting_feedback: Schema.optional(SilentCoachFeedbackTextItemSchema),
  next_meeting_feedback: Schema.optional(SilentCoachFeedbackTextItemSchema),
  hover_text: Schema.optional(Schema.String),
  score: Schema.optional(Schema.Number.annotations({ description: "This is the aggregate score of the skills breakdown." })),
  skills_breakdown: Schema.optional(Schema.Array(SilentCoachFeedbackSkillBreakdownItemSchema))
})
const CoachFeedbackResponseSchema = Schema.Struct({
  status: Schema.optional(Schema.String.annotations({ description: "See 'SilentCoachFeedbackStatus'" })),
  follow_up_conversation_uuid: Schema.optional(Schema.String),
  meeting_date: Schema.optional(Schema.String.annotations({ description: "The date/time of the meeting" })),
  header: Schema.optional(SilenctCoachFeedbackHeaderSchema),
  metrics: Schema.optional(SilentCoachFeedbackMetricsSchema),
  what_went_well: Schema.optional(SilentCoachFeedbackTextItemSchema),
  key_takeaway: Schema.optional(SilentCoachKeyTakeawaySchema),
  skills_feedback: Schema.optional(Schema.Array(SilentCoachFeedbackSkillItemSchema)),
  wrap_up_feedback: Schema.optional(SilentCoachFeedbackTextItemSchema),
  analytics: Schema.optional(Schema.Struct({})),
  error: Schema.optional(Schema.Struct({
  code: Schema.optional(Schema.String.annotations({ description: "This error code would be of type `SilentCoachFeedbackErrorCode`" })),
  message: Schema.optional(Schema.String)
}))
})
const LiveCoachFeedbackCreateRequestSchema = Schema.Struct({
  conversation_uuid: Schema.String.annotations({ description: "Unique identifier for the conversation" }),
  feedback_uuid: Schema.String.annotations({ description: "Unique identifier for the feedback" }),
  created_at: Schema.optional(Schema.String.annotations({ description: "ISO 8601 timestamp when the feedback was created" })),
  prompt: Schema.String.annotations({ description: "The prompt sent to the LLM" }),
  result: Schema.String.annotations({ description: "The result/feedback from the LLM" })
})

/**
 * This is the Persona API. It is used by Persona applications.

 *
 * @version 1.0.0
 */
const uuidParam = HttpApiSchema.param("uuid", Schema.String)
const getUser = HttpApiEndpoint.get("getUser")`/users/${uuidParam}`
  .addSuccess(UserSchema)
  .addError(ErrorSchema, { status: 401 })
  .addError(ErrorSchema, { status: 404 })

const updateUser = HttpApiEndpoint.put("updateUser")`/users/${uuidParam}`

const checkEmail = HttpApiEndpoint.get("checkEmail")"/check-email"
  .setUrlParams(Schema.Struct({
    email: Schema.String
  }))
  .addSuccess(CheckEmailResponseSchema)
  .addError(schemas-ErrorSchema, { status: 400 })
  .addError(schemas-ErrorSchema, { status: 404 })

const usersGroup = HttpApiGroup.make("users")
  .add(getUser)
  .add(updateUser)
  .add(checkEmail)

const getOnboarding = HttpApiEndpoint.get("getOnboarding")"/onboarding"

const submitOnboarding = HttpApiEndpoint.post("submitOnboarding")"/onboarding"
  .setPayload(OnboardingRequestSchema)

const onboardingGroup = HttpApiGroup.make("onboarding")
  .add(getOnboarding)
  .add(submitOnboarding)

const idParam = HttpApiSchema.param("id", Schema.String)
const getSubscription = HttpApiEndpoint.get("getSubscription")`/commerce/subscriptions/${idParam}`
  .addSuccess(CommerceGatewaySubscriptionSchema)
  .addError(schemas-ErrorSchema, { status: 400 })
  .addError(schemas-ErrorSchema, { status: 404 })

const subscriptionsGroup = HttpApiGroup.make("subscriptions")
  .add(getSubscription)

const createStripeSubscription = HttpApiEndpoint.post("createStripeSubscription")"/commerce/stripe/subscriptions"
  .setPayload(StripeSubscriptionCreateRequestSchema)
  .addSuccess(StripeSubscriptionResponseSchema)
  .addError(ErrorSchema, { status: 400 })

const subscription_idParam = HttpApiSchema.param("subscription_id", Schema.String)
const cancelStripeSubscription = HttpApiEndpoint.post("cancelStripeSubscription")`/commerce/stripe/subscriptions/${subscription_idParam}/cancel`
  .addSuccess(StripeSubscriptionResponseSchema)
  .addError(ErrorSchema, { status: 400 })
  .addError(ErrorSchema, { status: 404 })

const continueStripeSubscription = HttpApiEndpoint.post("continueStripeSubscription")`/commerce/stripe/subscriptions/${subscription_idParam}/continue`
  .addSuccess(StripeSubscriptionResponseSchema)
  .addError(ErrorSchema, { status: 400 })
  .addError(ErrorSchema, { status: 404 })

const stripeGroup = HttpApiGroup.make("stripe")
  .add(createStripeSubscription)
  .add(cancelStripeSubscription)
  .add(continueStripeSubscription)

const getProducts = HttpApiEndpoint.get("getProducts")"/commerce/products"
  .addSuccess(ProductsResponseSchema)
  .addError(schemas-ErrorSchema, { status: 400 })
  .addError(schemas-ErrorSchema, { status: 404 })

const productsGroup = HttpApiGroup.make("products")
  .add(getProducts)

const getPlans = HttpApiEndpoint.get("getPlans")"/commerce/plans"
  .setUrlParams(Schema.Struct({
    gateway: Schema.optional(Schema.Union(Schema.Literal("stripe"), Schema.Literal("apple"))),
    currency: Schema.optional(Schema.String),
    country: Schema.optional(Schema.String),
    include_trial: Schema.optional(Schema.Boolean)
  }))
  .addSuccess(Schema.Array(PlanSchema))
  .addError(schemas-ErrorSchema, { status: 400 })
  .addError(schemas-ErrorSchema, { status: 404 })

const plansGroup = HttpApiGroup.make("plans")
  .add(getPlans)

const startCall = HttpApiEndpoint.post("startCall")"/calls"

const call_uuidParam = HttpApiSchema.param("call_uuid", Schema.String)
const updateCall = HttpApiEndpoint.patch("updateCall")`/calls/${call_uuidParam}`

const slugParam = HttpApiSchema.param("slug", Schema.String)
const getBioPage = HttpApiEndpoint.get("getBioPage")`/bio-page/${slugParam}`

const getHomepage = HttpApiEndpoint.get("getHomepage")"/homepage"

const getFeedbackOptions = HttpApiEndpoint.get("getFeedbackOptions")"/persona/feedback"

const personaGroup = HttpApiGroup.make("persona")
  .add(startCall)
  .add(updateCall)
  .add(getBioPage)
  .add(getHomepage)
  .add(getFeedbackOptions)

const createConversation = HttpApiEndpoint.post("createConversation")"/conversations"
  .setPayload(ConversationCreateRequestSchema)
  .addSuccess(ConversationSchema, { status: 201 })

const uuidParam = HttpApiSchema.param("uuid", Schema.String)
const getConversation = HttpApiEndpoint.get("getConversation")`/conversations/${uuidParam}`
  .addSuccess(ConversationSchema)

const updateConversation = HttpApiEndpoint.put("updateConversation")`/conversations/${uuidParam}`
  .setPayload(ConversationUpdateRequestSchema)
  .addSuccess(ConversationSchema, { status: 201 })

const addMessageToConversation = HttpApiEndpoint.put("addMessageToConversation")`/conversations/${uuidParam}/message`
  .setPayload(ConversationAddMessageRequestSchema)
  .addSuccess(MessageSchema, { status: 201 })

const finishConversation = HttpApiEndpoint.post("finishConversation")`/conversations/${uuidParam}/finish`
  .setPayload(ConversationFinishRequestSchema)

const conversationsGroup = HttpApiGroup.make("conversations")
  .add(createConversation)
  .add(getConversation)
  .add(updateConversation)
  .add(addMessageToConversation)
  .add(finishConversation)

const instructor_slugParam = HttpApiSchema.param("instructor_slug", Schema.String)
const getContentCategories = HttpApiEndpoint.get("getContentCategories")`/personas/${instructor_slugParam}/categories`

const categoriesGroup = HttpApiGroup.make("categories")
  .add(getContentCategories)

const instructor_slugParam = HttpApiSchema.param("instructor_slug", Schema.String)
const getContents = HttpApiEndpoint.get("getContents")`/personas/${instructor_slugParam}/contents`
  .setUrlParams(Schema.Struct({
    parent_uuid: Schema.optional(Schema.String),
    uuids: Schema.optional(Schema.String),
    page: Schema.optional(Schema.Number),
    page_size: Schema.optional(Schema.Number)
  }))

const content_uuidParam = HttpApiSchema.param("content_uuid", Schema.String)
const getContentDetails = HttpApiEndpoint.get("getContentDetails")`/personas/${instructor_slugParam}/contents/${content_uuidParam}`

const getUserContentHistory = HttpApiEndpoint.get("getUserContentHistory")`/personas/${instructor_slugParam}/contents/user_history`
  .setUrlParams(Schema.Struct({
    page: Schema.optional(Schema.Number),
    page_size: Schema.optional(Schema.Number)
  }))

const updateUserContentHistory = HttpApiEndpoint.put("updateUserContentHistory")`/personas/${instructor_slugParam}/contents/user_history`

const contentsGroup = HttpApiGroup.make("contents")
  .add(getContents)
  .add(getContentDetails)
  .add(getUserContentHistory)
  .add(updateUserContentHistory)

const AppleSubscriptionConfirm = HttpApiEndpoint.post("AppleSubscriptionConfirm")"/commerce/apple/subscriptions/confirm"
  .setPayload(Schema.Struct({
  transactionJws: Schema.optional(Schema.String)
}))
  .addSuccess(AppleSubscriptionConfirmResponseSchema)
  .addError(ErrorSchema, { status: 400 })
  .addError(ErrorSchema, { status: 401 })
  .addError(ErrorSchema, { status: 404 })

const appleSubscriptionsConfirmGroup = HttpApiGroup.make("apple_subscriptions_confirm")
  .add(AppleSubscriptionConfirm)

const getRoleplayHomepage = HttpApiEndpoint.get("getRoleplayHomepage")"/roleplay-homepage"
  .setUrlParams(Schema.Struct({
    category_uuid_or_slug: Schema.optional(Schema.String),
    sub_category_uuid_or_slug: Schema.optional(Schema.String),
    show_your_path: Schema.optional(Schema.Boolean)
  }))

const scenario_uuid_or_slugParam = HttpApiSchema.param("scenario_uuid_or_slug", Schema.String)
const getRoleplayDetail = HttpApiEndpoint.get("getRoleplayDetail")`/roleplay-detail/${scenario_uuid_or_slugParam}`
  .setUrlParams(Schema.Struct({
    user_role_play_uuid: Schema.optional(Schema.String)
  }))
  .addSuccess(RoleplayDetailResponseSchema)

const createRoleplay = HttpApiEndpoint.post("createRoleplay")"/roleplay"
  .setPayload(RoleplayCreateRequestSchema)

const conversation_uuidParam = HttpApiSchema.param("conversation_uuid", Schema.String)
const getRoleplayFeedback = HttpApiEndpoint.get("getRoleplayFeedback")`/roleplay-feedback/${conversation_uuidParam}`
  .setUrlParams(Schema.Struct({
    async: Schema.optional(Schema.Boolean)
  }))
  .addSuccess(RoleplayFeedbackResponseSchema)
  .addError(RoleplayFeedbackResponseSchema, { status: 422 })

const roleplayGroup = HttpApiGroup.make("roleplay")
  .add(getRoleplayHomepage)
  .add(getRoleplayDetail)
  .add(createRoleplay)
  .add(getRoleplayFeedback)

const getHomepageForYou = HttpApiEndpoint.get("getHomepageForYou")"/homepage-for-you"

const homepageForYouGroup = HttpApiGroup.make("homepage-for-you")
  .add(getHomepageForYou)

const GetTextMessageHistory = HttpApiEndpoint.get("GetTextMessageHistory")"/chat"
  .setUrlParams(Schema.Struct({
    conversation_uuid: Schema.String,
    cursor: Schema.optional(Schema.String),
    limit: Schema.optional(Schema.Number)
  }))
  .addSuccess(Schema.Struct({
  messages: Schema.Array(MessageResponseSchema),
  cursor: CursorSchema
}))

const SendBotMessage = HttpApiEndpoint.post("SendBotMessage")"/chat"
  .setPayload(CreateMessageRequestBodySchema)
  .addSuccess(Schema.Array(MessageResponseSchema))

const messagesGroup = HttpApiGroup.make("messages")
  .add(GetTextMessageHistory)
  .add(SendBotMessage)

const slugParam = HttpApiSchema.param("slug", Schema.String)
const getPrePaywallCategory = HttpApiEndpoint.get("getPrePaywallCategory")`/pre-paywall-categories/${slugParam}`

const getPrePaywallHomepage = HttpApiEndpoint.get("getPrePaywallHomepage")"/pre-paywall-homepage"

const getPrePaywallBio = HttpApiEndpoint.get("getPrePaywallBio")`/pre-paywall-bio/${slugParam}`

const prePaywallGroup = HttpApiGroup.make("pre-paywall")
  .add(getPrePaywallCategory)
  .add(getPrePaywallHomepage)
  .add(getPrePaywallBio)

const getCalendarEvents = HttpApiEndpoint.get("getCalendarEvents")"/calendar-events"
  .setUrlParams(Schema.Struct({
    start_at: Schema.optional(Schema.String),
    end_at: Schema.optional(Schema.String)
  }))
  .addError(components-schemas-ErrorSchema, { status: 401 })
  .addError(components-schemas-ErrorSchema, { status: 403 })
  .addError(components-schemas-ErrorSchema, { status: 5XX })

const authorizeCalendar = HttpApiEndpoint.post("authorizeCalendar")"/calendar/authorize"
  .addError(components-schemas-ErrorSchema, { status: 400 })
  .addError(components-schemas-ErrorSchema, { status: 401 })
  .addError(components-schemas-ErrorSchema, { status: 5XX })

const calendarWebhook = HttpApiEndpoint.post("calendarWebhook")"/calendar/webhook"
  .setHeaders(Schema.Struct({
    "X-Goog-Channel-ID": Schema.String,
    "X-Goog-Resource-State": Schema.Union(Schema.Literal("sync"), Schema.Literal("exists"), Schema.Literal("not_exists")),
    "X-Goog-Resource-ID": Schema.String,
    "X-Goog-Resource-URI": Schema.optional(Schema.String),
    "X-Goog-Message-Number": Schema.optional(Schema.Number)
  }))
  .addSuccess(CalendarWebhookResponseSchema)
  .addError(components-schemas-ErrorSchema, { status: 400 })
  .addError(components-schemas-ErrorSchema, { status: 404 })
  .addError(components-schemas-ErrorSchema, { status: 5XX })

const calendarGroup = HttpApiGroup.make("calendar")
  .add(getCalendarEvents)
  .add(authorizeCalendar)
  .add(calendarWebhook)

const getCoachCalendar = HttpApiEndpoint.get("getCoachCalendar")"/coach/calendar"

const GetPreviousMeetings = HttpApiEndpoint.get("GetPreviousMeetings")"/coach/history"
  .setUrlParams(Schema.Struct({
    page_number: Schema.optional(Schema.Number),
    page_size: Schema.optional(Schema.Number)
  }))

const meeting_uuidParam = HttpApiSchema.param("meeting_uuid", Schema.String)
const GetMeetingDetails = HttpApiEndpoint.get("GetMeetingDetails")`/coach/calendar/meetings/${meeting_uuidParam}`

const GetMeetingsForNotifications = HttpApiEndpoint.get("GetMeetingsForNotifications")"/coach/calendar/meetings/notifications"

const CreateCoachConversation = HttpApiEndpoint.post("CreateCoachConversation")"/coach/conversations"
  .setPayload(CoachConversationCreateRequestSchema)
  .addSuccess(Schema.Struct({
  success: Schema.optional(Schema.Boolean)
}), { status: 201 })
  .addError(Schema.Struct({
  error: Schema.optional(Schema.String),
  details: Schema.optional(Schema.String)
}), { status: 400 })
  .addError(Schema.Struct({
  error: Schema.optional(Schema.String),
  details: Schema.optional(Schema.String)
}), { status: 422 })

const conversation_uuidParam = HttpApiSchema.param("conversation_uuid", Schema.String)
const getCoachFeedback = HttpApiEndpoint.get("getCoachFeedback")`/coach/feedbacks/${conversation_uuidParam}`
  .setUrlParams(Schema.Struct({
    async: Schema.optional(Schema.Boolean)
  }))
  .addSuccess(CoachFeedbackResponseSchema)
  .addError(CoachFeedbackResponseSchema, { status: 422 })

const coachGroup = HttpApiGroup.make("coach")
  .add(getCoachCalendar)
  .add(GetPreviousMeetings)
  .add(GetMeetingDetails)
  .add(GetMeetingsForNotifications)
  .add(CreateCoachConversation)
  .add(getCoachFeedback)

const CreateLiveCoachFeedback = HttpApiEndpoint.post("CreateLiveCoachFeedback")"/live-coach/feedbacks"
  .setPayload(LiveCoachFeedbackCreateRequestSchema)
  .addError(Schema.Struct({
  error: Schema.optional(Schema.String),
  details: Schema.optional(Schema.String)
}), { status: 400 })
  .addError(Schema.Struct({
  error: Schema.optional(Schema.String),
  details: Schema.optional(Schema.String)
}), { status: 422 })

const liveCoachGroup = HttpApiGroup.make("live-coach")
  .add(CreateLiveCoachFeedback)

const PersonaAPI = HttpApi.make("PersonaAPI")
  .add(usersGroup)
  .add(onboardingGroup)
  .add(subscriptionsGroup)
  .add(stripeGroup)
  .add(productsGroup)
  .add(plansGroup)
  .add(personaGroup)
  .add(conversationsGroup)
  .add(categoriesGroup)
  .add(contentsGroup)
  .add(appleSubscriptionsConfirmGroup)
  .add(roleplayGroup)
  .add(homepageForYouGroup)
  .add(messagesGroup)
  .add(prePaywallGroup)
  .add(calendarGroup)
  .add(coachGroup)
  .add(liveCoachGroup)

export { PersonaAPI }
