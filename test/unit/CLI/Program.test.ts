import { FileSystem, Path } from '@effect/platform'
import { NodeFileSystem, NodePath } from '@effect/platform-node'
import { describe, expect, it } from '@effect/vitest'
import * as Effect from 'effect/Effect'
import * as Layer from 'effect/Layer'
import * as Logger from 'effect/Logger'
import * as Program from '../../../src/CLI/Program.js'

/**
 * Create a test logger that captures log messages to a mutable array
 */
const makeTestLogger = (logs: Array<{ level: string; message: string }>) =>
  Logger.make(({ logLevel, message }) => {
    const messageStr = typeof message === 'string' ? message : String(message)
    logs.push({ level: logLevel.label, message: messageStr })
  })

// Test layer with real NodeFileSystem and NodePath
const TestLayer = Layer.merge(NodeFileSystem.layer, NodePath.layer)

describe('Program', () => {
  describe('generate', () => {
    it.effect('should read spec file using FileSystem service', () =>
      Effect.gen(function* () {
        const logs: Array<{ level: string; message: string }> = []
        const testLogger = makeTestLogger(logs)

        // Create a temp spec file
        const fs = yield* FileSystem.FileSystem
        const path = yield* Path.Path
        const tempDir = yield* fs.makeTempDirectoryScoped()
        const specPath = path.join(tempDir, 'test-spec.yaml')
        const outputPath = path.join(tempDir, 'output.ts')

        const specContent = `
openapi: '3.1.0'
info:
  title: Test API
  version: '1.0.0'
paths:
  /health:
    get:
      operationId: healthCheck
      responses:
        '200':
          description: Success
`
        yield* fs.writeFileString(specPath, specContent)

        // Run generate
        yield* Program.generate(specPath, outputPath).pipe(
          Effect.provide(Logger.replace(Logger.defaultLogger, testLogger))
        )

        // Verify output file was created
        const outputExists = yield* fs.exists(outputPath)
        expect(outputExists).toBe(true)

        // Verify output content
        const outputContent = yield* fs.readFileString(outputPath)
        expect(outputContent).toContain('Generated by @davidgoli/openapi-server-gen')
        expect(outputContent).toContain('healthCheck')

        // Verify logs were captured (when we implement Effect logging)
        const infoLogs = logs.filter((l) => l.level === 'INFO')
        expect(infoLogs.length).toBeGreaterThan(0)
      }).pipe(Effect.scoped, Effect.provide(TestLayer))
    )

    it.effect('should fail with error when spec file not found', () =>
      Effect.gen(function* () {
        const path = yield* Path.Path
        const tempDir = '/tmp'
        const specPath = path.join(tempDir, `non-existent-spec-${Date.now()}.yaml`)
        const outputPath = path.join(tempDir, 'output.ts')

        const result = yield* Effect.either(
          Program.generate(specPath, outputPath).pipe(Effect.catchAllDefect(Effect.fail))
        )

        expect(result._tag).toBe('Left')
      }).pipe(Effect.provide(TestLayer))
    )

    it.effect('should log info messages during generation', () =>
      Effect.gen(function* () {
        const logs: Array<{ level: string; message: string }> = []
        const testLogger = makeTestLogger(logs)

        const fs = yield* FileSystem.FileSystem
        const path = yield* Path.Path
        const tempDir = yield* fs.makeTempDirectoryScoped()
        const specPath = path.join(tempDir, 'test-spec.yaml')
        const outputPath = path.join(tempDir, 'output.ts')

        const specContent = `
openapi: '3.1.0'
info:
  title: Test API
  version: '1.0.0'
paths:
  /health:
    get:
      operationId: healthCheck
      responses:
        '200':
          description: Success
`
        yield* fs.writeFileString(specPath, specContent)

        yield* Program.generate(specPath, outputPath).pipe(
          Effect.provide(Logger.replace(Logger.defaultLogger, testLogger))
        )

        const infoLogs = logs.filter((l) => l.level === 'INFO')

        // Verify specific log messages
        expect(infoLogs.some((l) => l.message.includes('Reading'))).toBe(true)
        expect(infoLogs.some((l) => l.message.includes('Parsing'))).toBe(true)
        expect(infoLogs.some((l) => l.message.includes('Generating'))).toBe(true)
        expect(infoLogs.some((l) => l.message.includes('Writing'))).toBe(true)
      }).pipe(Effect.scoped, Effect.provide(TestLayer))
    )
  })
})
